









## 琐碎

记笔记时尽量以问题的方式记下来

项目初始化模板



ID递增改为ASSIGN_ID 雪花算法

代码生成器

包名

中文名

英文名

大写













## 路径参数和查询参数

/classes/123456/teachers?type=web



@GetMapping("/classes/{classId}/teachers")



@PathVariable("classId") Long classId;

@RequestParam(value = "type", required=false) String type



classId = 123456, type = web





## 排序

### 冒泡排序

两层循环 

i < length-1

 	j<length-i-1

​		交换





### 插入排序

维护一个有序序列

两层循环

i=1,;i<length-1; i++ 

​	j=i-1;  j>=0; j--

​		交换





### 快速排序

选择一个值（通常第一个、中间、最后一个）作为基准，小的在左，大的在右，分为两部分，然后递归对两部分分别再次选择基准排序，直至每组剩一个数



p(array,low,high) {

​	px = array[high]       array[low]

​	i =  low-1          i = low +1

​	for j = low; j <high; j++        j = low + 2 

​		if  array[j] < px

​			i ++ 

​			swap(array, i ,j)//交换

}



quickSort(array, low,high){

​	if low < high

​		pa =  p(array,low,high)

​		quickSort(array, low, pa - 1)

​		quickSort(array, pa+1, high)

}





## 银行家算法

​	保持安全状态，即	

​	在分配资源前，会检查分配资源后，系统中是否存在一个安全序列使得所有进程（线程）可以按某个顺序顺利执行完成。

​	相当于提前检查，









## 双检索单例模式示例

```Java
public class Singleton {
    // 使用volatile关键字确保多线程环境下的可见性和禁止指令重排序
    private static volatile Singleton instance;

    // 私有构造方法，防止外部直接创建实例
    private Singleton() {}

    // 获取单例实例的方法
    public static Singleton getInstance() {
        // 第一次检查：如果instance不为null，直接返回实例
        if (instance == null) {
            // 同步代码块，只有第一次实例化时才需要同步
            synchronized (Singleton.class) {
                // 第二次检查：进入同步块后再检查一次，以防多个线程在等待进入同步块时第一个线程已创建实例
                if (instance == null) {
                    // 只有一个线程能够执行到此处，创建实例
                    instance = new Singleton();
                }
            }
        }
        // 返回实例
        return instance;
    }
}
```







异步线程如果挂了，消息就丢失了，mq能保证服务器挂了，用户的消息还在



concurrenthashmap每次都锁一个头节点hashtable所有方法都是synchronized，





线程池太大，很多任务加到线程池后，cpu调度不过来了

spring 中 servlet是线程安全的

controller本身不是线程安全，它是否线程安全取决于里面的业务逻辑是否是线程安全



怎么判断业务逻辑是否线程安全

类中有没有公用的变量比如 private Map

一般是用作配置类中来使用，业务代码中不能用Map



每次注入的Bean的是同一个Bean，get





旁路缓存策略



优化后的旁路缓存

**延迟双删**：进方法时将缓存失效掉（删掉）更新数据库里的数据，延迟一段时间后以后再把它删掉

为什么删两次？

防止一些并发问题比如：  两个线程A，B，A删了缓存还没改数据库，B就读了还没改的数据，将缓存改成这个脏数据了，之后再读就是这个脏数据，了，

A：cache + db

B: cache(没读到) + db 

如果先写数据库，后删cache，如果事务比较大，一样会有A还没更新完，B就读进去了

A: db + cache

B: cache + db

这样几乎完全避免脏读，

等待时间设多久 100ms(根据实际情况)

删完直接返回， 然后起一个异步线程，让他等100ms再删一遍



缓存的一致性和事务的一致性有什么区别

缓存的一致性强调与数据库的数据一致，毕竟不是同一个数据源，spring的事务对缓存是不生效的，

数据库的一致性偏向于ACID的一个一致性，

原子性跟一致性有什么区别，//自己：原子性来保证数据的一致性

数据库：

CAP:   C 整个集群状态的一致性



可重复读：做了一个对幻读的优化，很大程度上可解决幻读

两个selcet 不能解决

间隙锁解决两个插入，在第一次插入时间区间不能正常插入





RestController = Controller + ResponseBody

ResponseBody 表示返回值是json格式



